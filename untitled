class Solution_findDisappearedNumbers(object):
    def findDisappearedNumbers(self, nums):
        
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        sorted_nums = sorted(nums)
        result =[]
        if sorted_nums and sorted_nums[0]>1:
                    num_of_elems = sorted_nums[0]-1
                    for j in range (num_of_elems):
                        result.append(j+1)
                        
        for i in range(len(sorted_nums)):
            if i==0:
                pass
            else:
                if sorted_nums[i]-sorted_nums[i-1]>=1:
                    num_of_elems = sorted_nums[i]-sorted_nums[i-1]-1
                    for j in range(num_of_elems):
                        result.append(sorted_nums[i-1]+j+1)
        
        
                        
        if sorted_nums and sorted_nums[-1]<len(sorted_nums):
                    num_of_elems = len(sorted_nums)-sorted_nums[-1]
                    for j in range (num_of_elems):
                        result.append(sorted_nums[-1]+j+1)        
                        
        return result    

    def findDisappearedNumbers2(self, nums):
        all_elems = []

        for i in range(len(nums)):
            all_elems.append(i+1)
        result = []
        n_set = set(nums)
        for elem in all_elems :
            if not elem in n_set :
                result.append(elem)
        return result    
            
class Solution_remove_duplicate(object):
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left_hand = None 
        right_hand = 0

        while right_hand < len(nums):
            if left_hand != None and nums[left_hand]==nums[right_hand]:
                del nums[left_hand]
            else :    
                left_hand = right_hand
                right_hand+=1
        return nums 


#print 1 
class Solution_two_sum(object):
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        left_bound = 0
        right_bound = None
        curr = None

        while numbers[left_bound]<= target:
            right_bound = self.locate_right_bound(numbers,left_bound,target)
            


            for i in range(right_bound-left_bound):
                curr = numbers[left_bound+i+1]

                if numbers[left_bound]+curr == target:
                    return left_bound+1,left_bound+i+1+1


            left_bound+=1




    def locate_right_bound(self,numbers,left_bound,target):

        right_bound = left_bound+1

        while right_bound<= len(numbers)-1 and numbers[left_bound]+numbers[right_bound]<=target:
            right_bound+=1

        return right_bound-1

i =[0,0,3,4]
  
#s = Solution()
#print Solution.twoSum(s,i,0) 
#print Solution.locate_right_bound(s,i,0,0)        
class Solution_Anagram(object):
    def isAnagram(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        return self.build_freq_table(s)==self.build_freq_table(t)
    
    def build_freq_table(self,str):
        
        freq_table = dict()
        
        for char in str:
            if not char in freq_table:
                freq_table[char]=1
            else :
                freq_table[char]+=1
        print freq_table
        return freq_table    

#sol = Solution()
#s='anagram'
#t='nagaram'
#print Solution.isAnagram(sol,s,t)   


class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        temp=""
        valid_result = ""
        freq_table = dict()
        start = 0
        i = start
        while start<len(s):
            

            if i<len(s) and not s[i] in freq_table:
                freq_table[s[i]]=1
                temp+=s[i]
                i+=1

            else:
                if len(temp)>len(valid_result):
                    valid_result = temp

                freq_table =dict()
                temp=""
                start=start+1
                i=start
            

                    
        if temp:
            if len(temp)>len(valid_result):
                    valid_result = temp       
        #sorted_result = sorted(valid_result,key =lambda item:len(item) )

        #print sorted_result[-1]
        #if sorted_result:
        #    return len(sorted_result[-1])
        #else : 
        #   return 0
        if valid_result:
            return len(valid_result)
        else :
            return 0              

sol = Solution()
#i ="dvdf"
#i = "abcdeedeee"
#i="bbbbb"
#i = "abcabcbb"
#i = "pwwkew"
#i = "anviaj"

print Solution.lengthOfLongestSubstring(sol,i)

